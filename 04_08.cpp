/*
Обеспечить распараллеливание вычислений на основе OpenMP при выполнении операции умножения матриц достаточно большого размера. 
Исследовать эффективность распараллеливания при использовании различных компиляторов
*/

// Matr_Mult.cpp
#include <iostream>
#include <omp.h> // Подключаем библиотеку OpenMP для распараллеливания
#include <time.h> // Для работы с временем (clock())

#define N 1024 // Размер матриц (N x N)

double a[N][N], b[N][N], c[N][N]; // Матрицы: a и b - входные, c - результат

using namespace std;

int main()
{
    int i, j, k; // Переменные для циклов
    double Tms;  // Переменная для измерения времени выполнения

    // Инициализация матриц a и b
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            a[i][j] = i * j; // Заполняем матрицу a произведением индексов
            b[i][j] = i * j; // Заполняем матрицу b произведением индексов
        }
    }

    // Засекаем начальное время
    Tms = clock();

    // Основной вычислительный блок с использованием OpenMP
#pragma omp parallel for shared(a, b, c) private(i, j, k)
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            c[i][j] = 0.0; // Обнуляем элемент результирующей матрицы
            for (k = 0; k < N; k++) {
                c[i][j] += a[i][k] * b[k][j]; // Выполняем умножение матриц
            }
        }
    }

    // Вычисляем общее время выполнения
    Tms = (clock() - Tms) / CLOCKS_PER_SEC;

    // Выводим время выполнения
    cout << "Time = " << Tms << " sec" << endl;

    return 0;
}

// почти двукратное ускорение за счет потоков OpenMP

/*
Time = 4.836 sec
*/
